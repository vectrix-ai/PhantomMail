# PhantomMail - AI Coding Agent Instructions

## Project Overview
PhantomMail is a LangGraph-based application that generates and sends realistic transport-related emails using Google Gemini 2.5 Pro. It follows a state machine pattern where emails flow through graph nodes that generate fake data, create AI-powered content, and send messages via Resend.

## Essential Commands

### Development Workflow
- **Run application**: `uv run phantommail` (prompts for recipient email)
- **Install/sync dependencies**: `uv sync`
- **Add dependency**: `uv add package_name` (never edit pyproject.toml manually)
- **Add dev dependency**: `uv add --dev package_name`
- **Launch LangGraph Studio**: `uvx --refresh --from "langgraph-cli[inmem]" --with-editable . --python 3.13 langgraph dev`

### Code Quality
- **Lint & fix**: `uv run ruff check --fix`
- **Format**: `uv run ruff format`
- **Run tests**: `uv run pytest`
- **Pre-commit hooks**: `pre-commit run --all-files`

## Architecture

### LangGraph State Machine
The core flow is defined in `src/phantommail/graphs/graph.py`:
1. **Conditional entry** (`email_types`): Routes to one of 8 email generators based on `email_type` or random selection
2. **Generation nodes**: Each email type (order, declaration, question, complaint, price_request, waiting_costs, update_order, random) has its own async node
3. **Send node**: All paths converge at `send_email` node before END

### State Management
`FakeEmailState` (TypedDict in `state.py`) passes data between nodes:
- `recipients`: List of email addresses
- `email_type`: Determines which generation node to use
- `email_attributes`: Fake data generated by faker modules
- `email`: Subject and body from AI generation
- `attachments`: Base64 encoded PDFs for customs declarations
- `messages`: LangChain message history with `add_messages` annotation

### Email Generation Pattern
All generator nodes in `nodes.py` follow this pattern:
```python
async def generate_<type>(self, state: FakeEmailState, config):
    # 1. Use faker to generate realistic data (from src/phantommail/fakers/)
    generator = <Type>Generator()
    data = generator.generate_<type>()
    
    # 2. Create AI prompt with SystemMessage + HumanMessage
    messages = [
        SystemMessage(content="You are generating a realistic email..."),
        HumanMessage(content=f"Data: {data}\nExample: {example_html}")
    ]
    
    # 3. Use structured output with Pydantic models
    structured_llm = self.llm.with_structured_output(Email)
    result = await structured_llm.ainvoke(messages)
    
    # 4. Return updated state
    return {"email": result, "email_attributes": data, ...}
```

## Key Conventions

### Faker Modules (`src/phantommail/fakers/`)
- Each email type has a dedicated generator class (e.g., `TransportOrderGenerator`, `DeclarationGenerator`)
- Load customer data from `src/phantommail/assets/customers.csv` for realistic sender details
- Use multiple Faker locales for European addresses: `self.fake_pickup = Faker("de_DE")`, `self.fake_delivery = Faker("en_GB")`
- Return Pydantic models (from `models/`) for type safety

### Pydantic Models (`src/phantommail/models/`)
- `Email`: AI-generated subject/body (used with `with_structured_output()`)
- `FullEmail`: Complete email with sender, recipients, attachments
- `TransportOrder`, `CustomsDeclaration`: Domain models for fake data
- All models inherit from `BaseModel` and use descriptive field names

### PDF Generation
For customs declarations, use `src/phantommail/helpers/html_to_pdf.py`:
```python
pdf_content = await create_pdf(html_content)  # Returns base64 string
state["attachments"] = [pdf_content]
```

### Logging
- Use `setup_logger(__name__)` from `phantommail.logger` (colorlog-based)
- Log at info level for major steps: generation, sending
- Log errors with context for debugging

## Configuration

### Environment Variables (`.env.local`)
Required:
- `RESEND_API_KEY`: From resend.com for email delivery
- `GOOGLE_API_KEY`: For Gemini AI (or use Vertex AI with `GOOGLE_CLOUD_PROJECT`)
- `SENDER_EMAIL`: From address (must be verified in Resend)

Optional:
- `LANGCHAIN_TRACING_V2=true`: Enable LangSmith debugging
- `LANGCHAIN_API_KEY`: LangSmith API key
- `LANGCHAIN_PROJECT=phantommail`: Project name for traces

### LangGraph Configuration (`langgraph.json`)
- Graph entry point: `./src/phantommail/graphs/graph.py:graph`
- Python version: 3.13
- Environment file: `.env`
- Config schema includes `sender` field passed from `main.py`

## Testing
- Tests in `tests/phantommail/` mirror `src/phantommail/` structure
- Use pytest fixtures for common setup
- Test faker generators independently from LangGraph nodes
- Example: `tests/phantommail/test_transport.py` validates `TransportOrderGenerator`

## Common Patterns

### Adding a New Email Type
1. Create faker in `src/phantommail/fakers/<type>.py` with `<Type>Generator` class
2. Add Pydantic model in `src/phantommail/models/` if needed
3. Create example HTML templates in `src/phantommail/examples/<type>_email.html`
4. Add async node method to `GraphNodes` in `nodes.py`
5. Register node and conditional edge in `graph.py`:
   ```python
   graph.add_node("generate_<type>", graph_nodes.generate_<type>)
   graph.add_conditional_edges(START, ..., {"<type>": "generate_<type>", ...})
   graph.add_edge("generate_<type>", "send_email")
   ```
6. Add `"<type>"` to `types` list in `email_types()` method

### Working with HTML Templates
- Store in `src/phantommail/examples/` as `.html` files
- Load with `resources.files("phantommail.examples").joinpath("file.html").read_text()`
- Pass as examples in HumanMessage to guide AI generation style
- For PDFs, create both `*_email.html` (email body) and `*_pdf.html` (attachment)

## Deployment
- **Local development**: Use LangGraph Studio with `langgraph dev` command
- **Self-hosted**: Follow [LangGraph deployment docs](https://langchain-ai.github.io/langgraph/how-tos/deploy-self-hosted/)
- **LangGraph Cloud**: Deploy from LangSmith dashboard after connecting repo
